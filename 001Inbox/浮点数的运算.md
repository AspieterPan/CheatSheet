---
Aliases: 
Tags: Computer/Compose 
DateCreated: 2023-07-11T11:03
DateModified: 2023-07-12T11:58
---
# 浮点数的运算
Top:: [[Computer Compose]]

## 浮点数加减运算步骤
---
1. 对阶
	- 阶数小阶向大阶对齐
		- 因为尾数只能表示小于 1 的数字
		- 对阶可能导致丢失末位精度
2. 尾数加减
	- 通常采用双符号位表示尾数，这样可以挽救尾数溢出
3. 规格化
	- 左规
		- 尾数最高数值位为无效位时，尾数左移，阶码减 1
	- 右规
		- 尾数双符号位不同时，尾数右移，阶码加 1
4. 舍入
	- 0 舍 1 入
	- 恒置 1
5. 判溢出
	- 阶码上溢
		- 抛出异常
	- 阶码下溢
		- 按机器 0 处理

### 浮点数的加减运算 - 舍入

1. "0" 舍 "1" 入法:
	- 类似于十进制数运算中的 " 四舍五入 " 法
	- 即在尾数右移时,被移去的最高数值位为 0,则舍去; 被移去的最高数值位为 1, 则在尾数的末位加 1
	- 这样做可能会使尾数又溢出,此时需再做一次右规。
2. 恒置 "1" 法:
	- 尾数右移时,不论丢掉的最高数值位是 "1" 还是 "0", 都使右移后的尾数末位恒置 "1"
	- 这种方法同样有使尾数变大和变小的两种可能。

## 强制类型转换
---
- 无损
	- char ->int ->long ->double
	- float -> double
- 有损
	- int -> float
		- 可能会损失精度
	- float -> int
		- 可能溢出，也可能损失精度

> [!attention] 教材上由于使用 32 位，对于类型转换论述可能不一样
> 我们现在电脑都是 64 位的，但教材上可能以 32 位电脑作为标准
> 值得注意的是 long 型，在 32 位机器中有 32 位，在 64 位机器中有 64 位
> 在 long 转 double 的类型转换中，教材中（即 32 位机器）会说没有精度丢失，但是实际操作（即 64 位机器）中是会有精度丢失的
